<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• Darwin AI Battle Arena - Voice Commentary</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2rem;
            color: #ccc;
        }
        
        .status-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        
        .status {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .status.waiting {
            color: #ff9800;
        }
        
        .status.error {
            color: #f44336;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }
        
        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }
        
        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(244, 67, 54, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .input-group input {
            padding: 10px;
            border: 2px solid #444;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            flex: 1;
        }
        
        .input-group input::placeholder {
            color: #999;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #4CAF50;
        }
        
        .transcript-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .transcript-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .transcript-header h2 {
            color: #4CAF50;
            font-size: 1.5rem;
        }
        
        .transcript-box {
            height: 300px;
            overflow-y: auto;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 15px;
            background: #1a1a1a;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .transcript-box::-webkit-scrollbar {
            width: 8px;
        }
        
        .transcript-box::-webkit-scrollbar-track {
            background: #333;
            border-radius: 4px;
        }
        
        .transcript-box::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 4px;
        }
        
        .transcript-box::-webkit-scrollbar-thumb:hover {
            background: #888;
        }
        
        .message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 6px;
            animation: fadeIn 0.3s ease-in;
        }
        
        .commentator-message {
            background: rgba(76, 175, 80, 0.2);
            border-left: 4px solid #4CAF50;
            color: #4CAF50;
        }
        
        .user-message {
            background: rgba(33, 150, 243, 0.2);
            border-left: 4px solid #2196F3;
            color: #2196F3;
        }
        
        .system-message {
            background: rgba(255, 152, 0, 0.2);
            border-left: 4px solid #ff9800;
            color: #ff9800;
            font-style: italic;
        }
        
        .message-time {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-right: 10px;
        }
        
        .message-speaker {
            font-weight: bold;
            margin-right: 10px;
        }
        
        .battle-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .info-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .info-card h3 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        .info-card p {
            color: #ccc;
            line-height: 1.5;
        }
        
        .mic-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }
        
        .mic-indicator.listening {
            background: #4CAF50;
        }
        
        .speaker-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff9800;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }
        
        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .mode-indicator {
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #3B82F6;
            color: white;
            font-size: 12px;
        }
        
        .mode-controls {
            margin: 10px 0;
        }
        
        .agent-selector {
            padding: 8px 12px;
            border: 1px solid #D1D5DB;
            border-radius: 6px;
            background-color: white;
            margin-right: 10px;
            min-width: 200px;
        }
        
        .agent-selector:disabled {
            background-color: #F3F4F6;
            color: #9CA3AF;
        }
        
        .agent-message {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 6px;
            border-left: 4px solid;
        }
        
        .agent-one-message {
            background: rgba(59, 130, 246, 0.2);
            border-left: 4px solid #3B82F6;
            color: #3B82F6;
        }
        
        .agent-two-message {
            background: rgba(16, 185, 129, 0.2);
            border-left: 4px solid #10B981;
            color: #10B981;
        }
        
        .agent-three-message {
            background: rgba(239, 68, 68, 0.2);
            border-left: 4px solid #EF4444;
            color: #EF4444;
        }
        
        .agent-four-message {
            background: rgba(139, 92, 246, 0.2);
            border-left: 4px solid #8B5CF6;
            color: #8B5CF6;
        }
        
        .agent-voice-tests {
            margin: 20px 0;
            padding: 15px;
            background-color: #F8FAFC;
            border-radius: 8px;
            border: 1px solid #E2E8F0;
        }
        
        .agent-voice-tests h4 {
            margin: 0 0 10px 0;
            color: #374151;
            font-size: 14px;
        }
        
        .agent-test-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .btn-danger {
            background-color: #EF4444;
            color: white;
            border: none;
            font-size: 14px;
            padding: 8px 16px;
            margin-left: 10px;
        }
        
        .btn-danger:hover {
            background-color: #DC2626;
        }
        
        .btn-agent-one {
            background-color: #3B82F6;
            color: white;
            border: none;
            font-size: 12px;
            padding: 8px 12px;
        }
        
        .btn-agent-two {
            background-color: #10B981;
            color: white;
            border: none;
            font-size: 12px;
            padding: 8px 12px;
        }
        
        .btn-agent-three {
            background-color: #EF4444;
            color: white;
            border: none;
            font-size: 12px;
            padding: 8px 12px;
        }
        
        .btn-agent-four {
            background-color: #8B5CF6;
            color: white;
            border: none;
            font-size: 12px;
            padding: 8px 12px;
        }
        
        .speaker-indicator.speaking {
            background: #4CAF50;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
            
            .battle-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî• Darwin AI Battle Arena</h1>
            <p>Real-time Voice Commentary with LiveKit</p>
        </div>
        
        <div class="status-panel">
            <div class="status" id="status">Waiting to join battle...</div>
        </div>
        
        <div class="controls">
            <button id="create-room-btn" class="btn btn-primary">Create Battle Room</button>
            <button id="join-room-btn" class="btn btn-secondary" disabled>Join Room</button>
            
            <!-- Mode Toggle -->
            <div class="mode-toggle">
                <button id="mode-toggle-btn" class="btn btn-info">üéôÔ∏è Commentary Mode</button>
                <span id="mode-indicator" class="mode-indicator">Commentary</span>
            </div>
            
            <!-- Commentary Mode Controls -->
            <div id="commentary-controls" class="mode-controls">
                <button id="ask-btn" class="btn btn-secondary" disabled>
                    <span class="mic-indicator" id="mic-indicator"></span>
                    Ask Commentator
                </button>
                <button id="stop-commentary-btn" class="btn btn-danger" style="display: none;">
                    üõë Stop Speech
                </button>
            </div>
            
            <!-- Agent Mode Controls -->
            <div id="agent-controls" class="mode-controls" style="display: none;">
                <select id="agent-selector" class="agent-selector" disabled>
                    <option value="">Select Agent</option>
                    <option value="One">Speedrunner (Fast & Competitive)</option>
                    <option value="Two">Bloom (Creative & Pattern-seeking)</option>
                    <option value="Three">Solver (Logical & Methodical)</option>
                    <option value="Four">Loader (Patient & Process-oriented)</option>
                </select>
                <button id="ask-agent-btn" class="btn btn-secondary" disabled>
                    <span class="mic-indicator" id="agent-mic-indicator"></span>
                    Ask Agent
                </button>
                <button id="stop-agent-btn" class="btn btn-danger" style="display: none;">
                    üõë Stop Speech
                </button>
            </div>
            
            <button id="refresh-transcript-btn" class="btn btn-secondary" disabled>Refresh Transcript</button>
            <button id="test-voice-btn" class="btn btn-warning">üé§ Test Commentator</button>
            
            <!-- Agent Voice Tests -->
            <div class="agent-voice-tests">
                <h4>Test Agent Voices:</h4>
                <div class="agent-test-buttons">
                    <button id="test-agent-one-btn" class="btn btn-agent-one">üé§ Agent One (Sarcastic)</button>
                    <button id="test-agent-two-btn" class="btn btn-agent-two">üé§ Agent Two (Professional)</button>
                    <button id="test-agent-three-btn" class="btn btn-agent-three">üé§ Agent Three (Competitive)</button>
                    <button id="test-agent-four-btn" class="btn btn-agent-four">üé§ Agent Four (Creative)</button>
                </div>
            </div>
          </div>
        
        <div class="input-group">
            <input type="text" id="room-name-input" placeholder="Enter room name (e.g., darwin-battle-project_1234567890)">
            <input type="text" id="user-name-input" placeholder="Your name" value="Spectator">
        </div>
        
        <div class="battle-info">
            <div class="info-card">
                <h3>üéØ Current Battle</h3>
                <p id="battle-info">No active battle</p>
            </div>
            <div class="info-card">
                <h3>üéôÔ∏è Voice Status</h3>
                <p id="voice-status">Not connected</p>
            </div>
            <div class="info-card">
                <h3>üë• Participants</h3>
                <p id="participant-count">0</p>
            </div>
        </div>
        
        <div class="transcript-container">
            <div class="transcript-header">
                <h2>üìù Live Transcript</h2>
                <button id="clear-transcript-btn" class="btn btn-danger">Clear</button>
            </div>
            <div class="transcript-box" id="transcript-box">
                <div class="message system-message">
                    <span class="message-time">--:--:--</span>
                    <span class="message-speaker">System:</span>
                    Welcome to Darwin AI Battle Arena! Create or join a room to start the voice commentary experience.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentRoom = null;
        let isListening = false;
        let audioEnabled = false;
        let currentMode = 'commentary'; // or 'agent'
        let selectedAgent = null; // For agent mode questions
        let currentAudio = null; // Track playing audio for instant stop
        let agentVoiceIds = {}; // Will be loaded from backend config
        let agentRecognition = null; // Track agent speech recognition instance
        
        // DOM elements
        const statusEl = document.getElementById('status');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const askBtn = document.getElementById('ask-btn');
        const refreshTranscriptBtn = document.getElementById('refresh-transcript-btn');
        const clearTranscriptBtn = document.getElementById('clear-transcript-btn');
        const testVoiceBtn = document.getElementById('test-voice-btn');
        const modeToggleBtn = document.getElementById('mode-toggle-btn');
        const modeIndicator = document.getElementById('mode-indicator');
        const commentaryControls = document.getElementById('commentary-controls');
        const agentControls = document.getElementById('agent-controls');
        const agentSelector = document.getElementById('agent-selector');
        const askAgentBtn = document.getElementById('ask-agent-btn');
        const agentMicIndicator = document.getElementById('agent-mic-indicator');
        const stopCommentaryBtn = document.getElementById('stop-commentary-btn');
        const stopAgentBtn = document.getElementById('stop-agent-btn');
        const testAgentOneBtn = document.getElementById('test-agent-one-btn');
        const testAgentTwoBtn = document.getElementById('test-agent-two-btn');
        const testAgentThreeBtn = document.getElementById('test-agent-three-btn');
        const testAgentFourBtn = document.getElementById('test-agent-four-btn');
        const roomNameInput = document.getElementById('room-name-input');
        const userNameInput = document.getElementById('user-name-input');
        const transcriptBox = document.getElementById('transcript-box');
        const micIndicator = document.getElementById('mic-indicator');
        const battleInfoEl = document.getElementById('battle-info');
        const voiceStatusEl = document.getElementById('voice-status');
        const participantCountEl = document.getElementById('participant-count');
        
        // API base URL
        const API_BASE = 'http://localhost:5003/api';
        
        // Event listeners
        createRoomBtn.addEventListener('click', () => {
            enableAudio();
            createBattleRoom();
        });
        joinRoomBtn.addEventListener('click', () => {
            enableAudio();
            joinRoom();
        });
        askBtn.addEventListener('click', () => {
            enableAudio();
            toggleListening();
        });
        refreshTranscriptBtn.addEventListener('click', () => {
            enableAudio();
            refreshTranscript();
        });
        clearTranscriptBtn.addEventListener('click', () => {
            enableAudio();
            clearTranscript();
        });
        testVoiceBtn.addEventListener('click', () => {
            enableAudio();
            testCommentatorVoice();
        });
        modeToggleBtn.addEventListener('click', () => {
            enableAudio();
            toggleMode();
        });
        agentSelector.addEventListener('change', () => {
            selectedAgent = agentSelector.value;
            askAgentBtn.disabled = !selectedAgent || !currentRoom;
        });
        askAgentBtn.addEventListener('click', () => {
            enableAudio();
            askAgent();
        });
        stopCommentaryBtn.addEventListener('click', () => {
            stopSpeech();
        });
        stopAgentBtn.addEventListener('click', () => {
            stopSpeech();
        });
        testAgentOneBtn.addEventListener('click', () => {
            enableAudio();
            testAgentVoice('One');
        });
        testAgentTwoBtn.addEventListener('click', () => {
            enableAudio();
            testAgentVoice('Two');
        });
        testAgentThreeBtn.addEventListener('click', () => {
            enableAudio();
            testAgentVoice('Three');
        });
        testAgentFourBtn.addEventListener('click', () => {
            enableAudio();
            testAgentVoice('Four');
        });
        
        function stopSpeech() {
            console.log('üõë Stopping all speech...');
            
            // Stop current audio immediately
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                console.log('‚úÖ Speech stopped');
            }
            
            // Hide stop buttons
            stopCommentaryBtn.style.display = 'none';
            stopAgentBtn.style.display = 'none';
            
            updateStatus('Speech stopped', 'waiting');
        }

        async function loadAgentVoiceConfig() {
            try {
                const response = await fetch(`${API_BASE}/livekit/agent-config`);
                if (response.ok) {
                    const result = await response.json();
                    // Extract voice IDs from config
                    agentVoiceIds = {
                        'One': result.agent_config.One.voice_id,
                        'Two': result.agent_config.Two.voice_id,
                        'Three': result.agent_config.Three.voice_id,
                        'Four': result.agent_config.Four.voice_id
                    };
                    console.log('‚úÖ Loaded agent voice IDs:', agentVoiceIds);
                } else {
                    console.error('Failed to load agent voice config');
                }
            } catch (error) {
                console.error('Error loading agent voice config:', error);
            }
        }
        
        // Initialize
        updateStatus('Ready to create battle room', 'waiting');
        loadAgentVoiceConfig(); // Load voice IDs from backend
        
        async function createBattleRoom() {
            try {
                updateStatus('Creating battle room...', 'waiting');
                createRoomBtn.disabled = true;
                
                const projectId = `project_${Date.now()}`;
                const response = await fetch(`${API_BASE}/livekit/create-battle-room`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        project_id: projectId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentRoom = result.room_name;
                    roomNameInput.value = currentRoom;
                    updateStatus(`Room created: ${currentRoom}`, 'success');
                    joinRoomBtn.disabled = false;
                    battleInfoEl.textContent = `Project: ${projectId}`;
                    addMessage('system', `Battle room created: ${currentRoom}`);
                    updateButtonStates();
                } else {
                    updateStatus(`Failed: ${result.error}`, 'error');
                    addMessage('system', `Error creating room: ${result.error}`);
                }
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
                addMessage('system', `Network error: ${error.message}`);
            } finally {
                createRoomBtn.disabled = false;
            }
        }
        
        async function joinRoom() {
            try {
                const roomName = roomNameInput.value.trim();
                const userName = userNameInput.value.trim() || 'Spectator';
                
                if (!roomName) {
                    updateStatus('Please enter a room name', 'error');
                    return;
                }
                
                updateStatus('Joining room...', 'waiting');
                joinRoomBtn.disabled = true;
                
                const response = await fetch(`${API_BASE}/livekit/join-room`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        room_name: roomName,
                        user_name: userName
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentRoom = roomName;
                    updateStatus(`Joined room: ${roomName}`, 'success');
                    askBtn.disabled = false;
                    refreshTranscriptBtn.disabled = false;
                    voiceStatusEl.textContent = 'Connected to LiveKit';
                    addMessage('system', `Joined room as ${userName}`);
                    
                    // Load initial transcript
                    refreshTranscript();
                } else {
                    updateStatus(`Failed to join: ${result.error}`, 'error');
                    addMessage('system', `Error joining room: ${result.error}`);
                }
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
                addMessage('system', `Network error: ${error.message}`);
            } finally {
                joinRoomBtn.disabled = false;
                updateButtonStates();
            }
        }
        
        async function askCommentator(question) {
            if (!currentRoom) {
                updateStatus('Please join a room first', 'error');
                return;
            }
            
            try {
                updateStatus('Asking commentator...', 'waiting');
                
                const response = await fetch(`${API_BASE}/livekit/ask-commentator`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        room_name: currentRoom,
                        question: question
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Refresh transcript to get the latest conversation
                    await refreshTranscript();
                    
                    // Play commentator's response as audio
                    updateStatus('Commentator is speaking...', 'waiting');
                    await speakText(result.response_text);
                    updateStatus('Commentator responded!', 'success');
                } else {
                    updateStatus(`Error: ${result.error}`, 'error');
                    addMessage('system', `Error asking commentator: ${result.error}`);
                }
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
                addMessage('system', `Network error: ${error.message}`);
            }
        }
        
        async function refreshTranscript() {
            if (!currentRoom) return;
            
            try {
                const response = await fetch(`${API_BASE}/livekit/get-transcript?room_name=${currentRoom}`);
                const result = await response.json();
                
                if (result.success && result.transcript) {
                    // Only update if transcript has changed
                    const currentLength = transcriptBox.children.length;
                    const newLength = result.transcript.length;
                    
                    if (newLength > currentLength) {
                        // Add only new messages
                        const newMessages = result.transcript.slice(currentLength);
                        newMessages.forEach(msg => {
                            addMessage(msg.speaker.toLowerCase(), msg.text, msg.time_formatted);
                        });
                        console.log(`Added ${newMessages.length} new messages to transcript`);
                    } else if (currentLength === 0) {
                        // Initial load - add all messages
                        result.transcript.forEach(msg => {
                            addMessage(msg.speaker.toLowerCase(), msg.text, msg.time_formatted);
                        });
                    }
                }
            } catch (error) {
                console.error('Error refreshing transcript:', error);
            }
        }
        
        function toggleListening() {
            if (isListening) {
                stopListening();
            } else {
                startListening();
            }
        }
        
        async function transcribeAudioForAgent() {
            return new Promise((resolve, reject) => {
                // Check if speech recognition is supported
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    updateStatus('Speech recognition not supported in this browser', 'error');
                    reject(new Error('Speech recognition not supported'));
                    return;
                }
                
                try {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognition = new SpeechRecognition();
                    agentRecognition = recognition;  // Store globally
                    
                    recognition.continuous = false;
                    recognition.interimResults = true;
                    recognition.lang = 'en-US';
                    
                    let hasResolved = false;
                    
                    recognition.onstart = function() {
                        agentMicIndicator.classList.add('listening');
                        console.log('Agent speech recognition started');
                    };
                    
                    recognition.onresult = function(event) {
                        let finalTranscript = '';
                        
                        // Process all results
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript;
                            } else {
                                // Show interim results
                                updateStatus(`Listening: "${transcript}"`, 'waiting');
                            }
                        }
                        
                        // Process final result
                        if (finalTranscript && !hasResolved) {
                            hasResolved = true;
                            const question = finalTranscript.trim();
                            console.log('Agent question:', question);
                            
                            // Stop recognition
                            recognition.stop();
                            agentMicIndicator.classList.remove('listening');
                            agentRecognition = null;  // Clear global reference
                            
                            resolve(question);
                        }
                    };
                    
                    recognition.onerror = function(event) {
                        console.error('Speech recognition error:', event.error);
                        agentMicIndicator.classList.remove('listening');
                        agentRecognition = null;  // Clear global reference
                        if (!hasResolved) {
                            hasResolved = true;
                            reject(new Error(event.error));
                        }
                    };
                    
                    recognition.onend = function() {
                        agentMicIndicator.classList.remove('listening');
                        agentRecognition = null;  // Clear global reference
                        console.log('Agent speech recognition ended');
                        if (!hasResolved) {
                            hasResolved = true;
                            reject(new Error('Speech recognition ended without result'));
                        }
                    };
                    
                    // Start recognition
                    recognition.start();
                    
                } catch (error) {
                    console.error('Speech recognition setup error:', error);
                    updateStatus(`Microphone error: ${error.message}`, 'error');
                    reject(error);
                }
            });
        }

        async function startListening() {
            try {
                // Check if speech recognition is supported
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    updateStatus('Speech recognition not supported in this browser', 'error');
                    addMessage('system', 'Speech recognition not supported. Please use Chrome or Edge.');
                    return;
                }
                
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                
                recognition.continuous = false;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                
                recognition.onstart = function() {
                    isListening = true;
                    micIndicator.classList.add('listening');
                    askBtn.textContent = 'Stop Recording';
                    updateStatus('Listening... Speak now!', 'waiting');
                    console.log('Speech recognition started');
                };
                
                recognition.onresult = async function(event) {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    
                    // Process all results
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }
                    
                    // Show interim results as you speak
                    if (interimTranscript) {
                        updateStatus(`Listening: "${interimTranscript}"`, 'waiting');
                    }
                    
                    // Process final result
                    if (finalTranscript) {
                        const question = finalTranscript.trim();
                        console.log('You said:', question);
                        
                        // Add your question to transcript immediately
                        addMessage('user', question);
                        
                        // Stop listening
                        recognition.stop();
                        isListening = false;
                        micIndicator.classList.remove('listening');
                        askBtn.textContent = 'Ask Commentator';
                        
                        // Ask the commentator
                        if (question) {
                            await askCommentator(question);
                        } else {
                            updateStatus('No speech detected', 'error');
                        }
                    }
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    isListening = false;
                    micIndicator.classList.remove('listening');
                    askBtn.textContent = 'Ask Commentator';
                    updateStatus(`Speech recognition error: ${event.error}`, 'error');
                };
                
                recognition.onend = function() {
                    isListening = false;
                    micIndicator.classList.remove('listening');
                    askBtn.textContent = 'Ask Commentator';
                    console.log('Speech recognition ended');
                };
                
                // Start recognition
                recognition.start();
                
            } catch (error) {
                updateStatus(`Microphone error: ${error.message}`, 'error');
                addMessage('system', `Microphone access denied: ${error.message}`);
            }
        }
        
        function stopListening() {
            // Speech recognition will stop automatically when it detects speech
            // This function is kept for compatibility but doesn't need to do much
            isListening = false;
            micIndicator.classList.remove('listening');
            askBtn.textContent = 'Ask Commentator';
            updateStatus('Stopped listening', 'waiting');
        }
        
        // Speech recognition is now handled directly in startListening()
        
        // Enable audio playback (required for browser autoplay policies)
        function enableAudio() {
            if (!audioEnabled) {
                // Create a silent audio to enable audio context
                const audio = new Audio();
                audio.volume = 0;
                audio.play().then(() => {
                    audioEnabled = true;
                    console.log('‚úÖ Audio enabled for playback');
                }).catch((error) => {
                    console.log('‚ö†Ô∏è Audio not yet enabled, user interaction required');
                });
            }
        }
        
        // Mode toggle functionality
        function toggleMode() {
            // Stop current audio immediately
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                console.log('üõë Audio stopped for mode switch');
            }
            
            // Switch mode
            currentMode = currentMode === 'commentary' ? 'agent' : 'commentary';
            
            // Update UI
            if (currentMode === 'commentary') {
                modeToggleBtn.textContent = 'üéôÔ∏è Commentary Mode';
                modeIndicator.textContent = 'Commentary';
                modeIndicator.style.backgroundColor = '#3B82F6';
                commentaryControls.style.display = 'block';
                agentControls.style.display = 'none';
            } else {
                modeToggleBtn.textContent = 'ü§ñ Agent Mode';
                modeIndicator.textContent = 'Agent';
                modeIndicator.style.backgroundColor = '#8B5CF6';
                commentaryControls.style.display = 'none';
                agentControls.style.display = 'block';
            }
            
            // Update button states
            updateButtonStates();
            
            // Set mode on server
            if (currentRoom) {
                setRoomMode(currentRoom, currentMode);
            }
            
            console.log(`üîÑ Switched to ${currentMode} mode`);
        }
        
        async function setRoomMode(roomName, mode) {
            try {
                const response = await fetch(`${API_BASE}/livekit/set-mode`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        room_name: roomName,
                        mode: mode
                    })
                });
                
                if (response.ok) {
                    console.log(`‚úÖ Room ${roomName} set to ${mode} mode`);
                } else {
                    console.error('‚ùå Failed to set room mode');
                }
            } catch (error) {
                console.error('‚ùå Error setting room mode:', error);
            }
        }
        
        function updateButtonStates() {
            const hasRoom = !!currentRoom;
            const hasAgent = !!selectedAgent;
            
            askBtn.disabled = !hasRoom || currentMode !== 'commentary';
            askAgentBtn.disabled = !hasRoom || !hasAgent || currentMode !== 'agent';
            agentSelector.disabled = !hasRoom || currentMode !== 'agent';
        }
        
        async function askAgent() {
            if (!selectedAgent || !currentRoom) {
                updateStatus('Please select an agent first', 'error');
                return;
            }
            
            // Stop any existing recognition
            if (agentRecognition) {
                try {
                    agentRecognition.stop();
                    console.log('üõë Stopped existing recognition');
                } catch (e) {
                    // Ignore errors if already stopped
                }
                agentRecognition = null;
            }
            
            try {
                updateStatus('Listening for your question...', 'listening');
                
                // Show listening indicator
                agentMicIndicator.classList.add('listening');
                
                // Use speech recognition
                const question = await transcribeAudioForAgent();
                
                // Hide listening indicator (already hidden in function, but just in case)
                agentMicIndicator.classList.remove('listening');
                
                if (!question) {
                    updateStatus('No speech detected', 'error');
                    return;
                }
                
                updateStatus('Agent is thinking...', 'waiting');
                
                // Add user question to transcript immediately
                addMessage('user', `(to ${selectedAgent}) ${question}`);
                
                // Ask the agent
                const response = await fetch(`${API_BASE}/livekit/ask-agent`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        room_name: currentRoom,
                        agent_name: selectedAgent,
                        question: question
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    // Add agent response to transcript
                    addMessage(`agent-${selectedAgent.toLowerCase()}`, result.response_text);
                    
                    // Speak the response using the agent's unique voice
                    const agentVoiceId = agentVoiceIds[selectedAgent] || 'gnPxliFHTp6OK6tcoA6i';
                    console.log(`Speaking as Agent ${selectedAgent} with voice ${agentVoiceId}`);
                    await speakText(result.response_text, agentVoiceId);
                    
                    updateStatus('Agent responded!', 'success');
                } else {
                    const errorData = await response.json();
                    console.error('Agent response error:', errorData);
                    updateStatus(`Failed to get agent response: ${errorData.error || 'Unknown error'}`, 'error');
                }
                
            } catch (error) {
                console.error('Error asking agent:', error);
                updateStatus(`Error asking agent: ${error.message}`, 'error');
            }
        }
        
        function addMessage(speaker, text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${speaker}`;
            
            const time = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="speaker">${speaker}</span>
                    <span class="timestamp">${time}</span>
                </div>
                <div class="message-content">${text}</div>
            `;
            
            transcriptBox.appendChild(messageDiv);
            transcriptBox.scrollTop = transcriptBox.scrollHeight;
        }

        // Test function to play hardcoded message
        async function testCommentatorVoice() {
            console.log('üé§ Testing commentator voice with hardcoded message...');
            enableAudio();
            
            const testMessage = "Welcome to the AI coding battle arena! Let's go! üî•";
            
            try {
                const response = await fetch(`${API_BASE}/livekit/speak-text`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: testMessage,
                        voice_id: 'gnPxliFHTp6OK6tcoA6i'
                    })
                });
                
                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    
                    audio.onended = () => {
                        URL.revokeObjectURL(audioUrl);
                        console.log('‚úÖ Test commentator finished speaking');
                    };
                    audio.onerror = (error) => {
                        console.error('‚ùå Test audio playback error:', error);
                    };
                    audio.oncanplaythrough = () => {
                        console.log('üéµ Test audio ready to play');
                    };
                    
                    await audio.play();
                    console.log('üé§ Test commentator started speaking');
                } else {
                    console.error('‚ùå Test TTS API error:', response.status);
                }
            } catch (error) {
                console.error('‚ùå Test error:', error);
            }
        }
        
        // Test function for individual agent voices
        async function testAgentVoice(agentName) {
            console.log(`üé§ Testing Agent ${agentName} voice...`);
            enableAudio();
            
            const agentMessages = {
                'One': "Yo, what's up? I'm Agent One and I'm here to crush this code! üòè",
                'Two': "Greetings. I am Agent Two, and I shall execute this task with precision and excellence.",
                'Three': "LET'S GO! Agent Three here, ready to DOMINATE this battle! üî•",
                'Four': "Hello there! Agent Four speaking - let's create something beautiful together ‚ú®"
            };
            
            const testMessage = agentMessages[agentName];
            
            try {
                updateStatus(`Testing Agent ${agentName} voice...`, 'waiting');
                
                // Get agent's voice ID from loaded config
                const voiceId = agentVoiceIds[agentName] || 'gnPxliFHTp6OK6tcoA6i'; // Fallback to default if not loaded
                console.log(`Using voice ID for Agent ${agentName}: ${voiceId}`);
                
                const response = await fetch(`${API_BASE}/livekit/speak-text`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: testMessage,
                        voice_id: voiceId
                    })
                });
                
                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    currentAudio = audio;
                    
                    audio.oncanplaythrough = () => {
                        console.log(`‚úÖ Agent ${agentName} audio loaded and ready to play`);
                    };
                    
                    audio.onloadstart = () => {
                        console.log(`üîÑ Loading Agent ${agentName} audio...`);
                    };
                    
                    await audio.play();
                    console.log(`üéµ Playing Agent ${agentName} voice test`);
                    updateStatus(`Agent ${agentName} voice test playing!`, 'success');
                    
                    audio.onended = () => {
                        currentAudio = null;
                        URL.revokeObjectURL(audioUrl);
                        console.log(`‚úÖ Agent ${agentName} voice test completed`);
                        updateStatus(`Agent ${agentName} voice test completed!`, 'success');
                    };
                    
                } else {
                    console.error(`‚ùå Failed to get Agent ${agentName} audio from server`);
                    updateStatus(`Failed to test Agent ${agentName} voice`, 'error');
                }
                
            } catch (error) {
                console.error(`‚ùå Error testing Agent ${agentName} voice:`, error);
                updateStatus(`Error testing Agent ${agentName} voice`, 'error');
            }
        }

        async function speakText(text, voiceId = 'gnPxliFHTp6OK6tcoA6i') {
            // Enable audio if not already enabled
            enableAudio();
            
            try {
                // Use ElevenLabs TTS for high-quality voice
                const response = await fetch(`${API_BASE}/livekit/speak-text`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        voice_id: voiceId  // Use provided voice ID
                    })
                });
                
                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    currentAudio = audio;  // Track for instant stop
                    
                    // Show stop button based on current mode
                    if (currentMode === 'commentary') {
                        stopCommentaryBtn.style.display = 'inline-block';
                    } else {
                        stopAgentBtn.style.display = 'inline-block';
                    }
                    
                    return new Promise((resolve) => {
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            currentAudio = null;
                            // Hide stop button
                            stopCommentaryBtn.style.display = 'none';
                            stopAgentBtn.style.display = 'none';
                            console.log('‚úÖ Speech finished');
                            resolve();
                        };
                        audio.onerror = (error) => {
                            console.error('‚ùå Audio playback error:', error);
                            resolve();
                        };
                        audio.oncanplaythrough = () => {
                            console.log('üéµ Audio ready to play');
                        };
                        audio.onloadstart = () => {
                            console.log('üîÑ Loading audio...');
                        };
                        
                        // Try to play the audio
                        audio.play().then(() => {
                            console.log('üé§ Commentator started speaking');
                        }).catch((error) => {
                            console.error('‚ùå Audio play failed:', error);
                            // Try fallback
                            fallbackSpeakText(text).then(resolve);
                        });
                    });
                } else {
                    console.error('TTS API error:', response.status);
                    // Fallback to browser TTS
                    await fallbackSpeakText(text);
                }
            } catch (error) {
                console.error('Error speaking text:', error);
                // Fallback to browser TTS
                await fallbackSpeakText(text);
            }
        }
        
        async function fallbackSpeakText(text) {
            try {
                // Use Web Speech API with better voice settings
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Configure voice settings for commentator
                    utterance.rate = 0.85;  // Slightly slower for clarity
                    utterance.pitch = 0.7;   // Lower pitch for commentator
                    utterance.volume = 1.0;  // Full volume
                    
                    // Try to use a male voice for commentator
                    const voices = speechSynthesis.getVoices();
                    const maleVoice = voices.find(voice => 
                        voice.name.includes('Male') || 
                        voice.name.includes('David') || 
                        voice.name.includes('Alex') ||
                        voice.name.includes('Daniel') ||
                        voice.name.includes('Google UK English Male') ||
                        voice.name.includes('Microsoft David Desktop')
                    );
                    
                    if (maleVoice) {
                        utterance.voice = maleVoice;
                        console.log('Using male voice:', maleVoice.name);
                    }
                    
                    speechSynthesis.speak(utterance);
                    
                    return new Promise((resolve) => {
                        utterance.onstart = () => {
                            console.log('Commentator started speaking');
                        };
                        utterance.onend = () => {
                            console.log('Commentator finished speaking');
                            resolve();
                        };
                        utterance.onerror = (event) => {
                            console.error('Speech synthesis error:', event.error);
                            resolve();
                        };
                    });
                }
            } catch (error) {
                console.error('Fallback TTS error:', error);
            }
        }
        
        function addMessage(speaker, text, timestamp = null) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${speaker}-message`;
            
            const time = timestamp || new Date().toLocaleTimeString();
            messageEl.innerHTML = `
                <span class="message-time">${time}</span>
                <span class="message-speaker">${speaker.charAt(0).toUpperCase() + speaker.slice(1)}:</span>
                ${text}
            `;
            
            transcriptBox.appendChild(messageEl);
            transcriptBox.scrollTop = transcriptBox.scrollHeight;
        }
        
        function clearTranscript() {
            transcriptBox.innerHTML = '';
            addMessage('system', 'Transcript cleared');
        }
        
        function updateStatus(message, type = 'success') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        // Auto-refresh room status
        setInterval(async () => {
            if (currentRoom) {
                try {
                    const response = await fetch(`${API_BASE}/livekit/room-status?room_name=${currentRoom}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        participantCountEl.textContent = `${result.participant_count} participants`;
                    }
                } catch (error) {
                    console.error('Error checking room status:', error);
                }
            }
        }, 5000);
    </script>
</body>
</html>
