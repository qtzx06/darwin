{
  "version": 3,
  "sources": ["../../three/examples/jsm/geometries/RoundedBoxGeometry.js"],
  "sourcesContent": ["import {\r\n\tBoxGeometry,\r\n\tVector3\r\n} from 'three';\r\n\r\nconst _tempNormal = new Vector3();\r\n\r\nfunction getUv( faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength ) {\r\n\r\n\tconst totArcLength = 2 * Math.PI * radius / 4;\r\n\r\n\t// length of the planes between the arcs on each axis\r\n\tconst centerLength = Math.max( sideLength - 2 * radius, 0 );\r\n\tconst halfArc = Math.PI / 4;\r\n\r\n\t// Get the vector projected onto the Y plane\r\n\t_tempNormal.copy( normal );\r\n\t_tempNormal[ projectionAxis ] = 0;\r\n\t_tempNormal.normalize();\r\n\r\n\t// total amount of UV space alloted to a single arc\r\n\tconst arcUvRatio = 0.5 * totArcLength / ( totArcLength + centerLength );\r\n\r\n\t// the distance along one arc the point is at\r\n\tconst arcAngleRatio = 1.0 - ( _tempNormal.angleTo( faceDirVector ) / halfArc );\r\n\r\n\tif ( Math.sign( _tempNormal[ uvAxis ] ) === 1 ) {\r\n\r\n\t\treturn arcAngleRatio * arcUvRatio;\r\n\r\n\t} else {\r\n\r\n\t\t// total amount of UV space alloted to the plane between the arcs\r\n\t\tconst lenUv = centerLength / ( totArcLength + centerLength );\r\n\t\treturn lenUv + arcUvRatio + arcUvRatio * ( 1.0 - arcAngleRatio );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A special type of box geometry with rounded corners and edges.\r\n *\r\n * ```js\r\n * const geometry = new THREE.RoundedBoxGeometry();\r\n * const material = new THREE.MeshStandardMaterial( { color: 0x00ff00 } );\r\n * const cube = new THREE.Mesh( geometry, material );\r\n * scene.add( cube );\r\n * ```\r\n *\r\n * @augments BoxGeometry\r\n * @three_import import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';\r\n */\r\nclass RoundedBoxGeometry extends BoxGeometry {\r\n\r\n\t/**\r\n\t * Constructs a new rounded box geometry.\r\n\t *\r\n\t * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.\r\n\t * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.\r\n\t * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.\r\n\t * @param {number} [segments=2] - Number of segments that form the rounded corners.\r\n\t * @param {number} [radius=0.1] - The radius of the rounded corners.\r\n\t */\r\n\tconstructor( width = 1, height = 1, depth = 1, segments = 2, radius = 0.1 ) {\r\n\r\n\t\t// calculate total segments needed &\r\n\t\t// ensure it's odd so that we have a plane connecting the rounded corners\r\n\t\tconst totalSegments = segments * 2 + 1;\r\n\r\n\t\t// ensure radius isn't bigger than shortest side\r\n\t\tradius = Math.min( width / 2, height / 2, depth / 2, radius );\r\n\r\n\t\t// start with a unit box geometry, its vertices will be modified to form the rounded box\r\n\t\tsuper( 1, 1, 1, totalSegments, totalSegments, totalSegments );\r\n\r\n\t\tthis.type = 'RoundedBoxGeometry';\r\n\r\n\t\t/**\r\n\t\t * Holds the constructor parameters that have been\r\n\t\t * used to generate the geometry. Any modification\r\n\t\t * after instantiation does not change the geometry.\r\n\t\t *\r\n\t\t * @type {Object}\r\n\t\t */\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\tsegments: segments,\r\n\t\t\tradius: radius,\r\n\t\t};\r\n\r\n\t\t// if totalSegments is 1, no rounding is needed - return regular box\r\n\t\tif ( totalSegments === 1 ) return;\r\n\r\n\t\tconst geometry2 = this.toNonIndexed();\r\n\r\n\t\tthis.index = null;\r\n\t\tthis.attributes.position = geometry2.attributes.position;\r\n\t\tthis.attributes.normal = geometry2.attributes.normal;\r\n\t\tthis.attributes.uv = geometry2.attributes.uv;\r\n\r\n\t\t//\r\n\r\n\t\tconst position = new Vector3();\r\n\t\tconst normal = new Vector3();\r\n\r\n\t\tconst box = new Vector3( width, height, depth ).divideScalar( 2 ).subScalar( radius );\r\n\r\n\t\tconst positions = this.attributes.position.array;\r\n\t\tconst normals = this.attributes.normal.array;\r\n\t\tconst uvs = this.attributes.uv.array;\r\n\r\n\t\tconst faceTris = positions.length / 6;\r\n\t\tconst faceDirVector = new Vector3();\r\n\t\tconst halfSegmentSize = 0.5 / totalSegments;\r\n\r\n\t\tfor ( let i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tposition.fromArray( positions, i );\r\n\t\t\tnormal.copy( position );\r\n\t\t\tnormal.x -= Math.sign( normal.x ) * halfSegmentSize;\r\n\t\t\tnormal.y -= Math.sign( normal.y ) * halfSegmentSize;\r\n\t\t\tnormal.z -= Math.sign( normal.z ) * halfSegmentSize;\r\n\t\t\tnormal.normalize();\r\n\r\n\t\t\tpositions[ i + 0 ] = box.x * Math.sign( position.x ) + normal.x * radius;\r\n\t\t\tpositions[ i + 1 ] = box.y * Math.sign( position.y ) + normal.y * radius;\r\n\t\t\tpositions[ i + 2 ] = box.z * Math.sign( position.z ) + normal.z * radius;\r\n\r\n\t\t\tnormals[ i + 0 ] = normal.x;\r\n\t\t\tnormals[ i + 1 ] = normal.y;\r\n\t\t\tnormals[ i + 2 ] = normal.z;\r\n\r\n\t\t\tconst side = Math.floor( i / faceTris );\r\n\r\n\t\t\tswitch ( side ) {\r\n\r\n\t\t\t\tcase 0: // right\r\n\r\n\t\t\t\t\t// generate UVs along Z then Y\r\n\t\t\t\t\tfaceDirVector.set( 1, 0, 0 );\r\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'z', 'y', radius, depth );\r\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 1: // left\r\n\r\n\t\t\t\t\t// generate UVs along Z then Y\r\n\t\t\t\t\tfaceDirVector.set( - 1, 0, 0 );\r\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'y', radius, depth );\r\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 2: // top\r\n\r\n\t\t\t\t\t// generate UVs along X then Z\r\n\t\t\t\t\tfaceDirVector.set( 0, 1, 0 );\r\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\r\n\t\t\t\t\tuvs[ j + 1 ] = getUv( faceDirVector, normal, 'z', 'x', radius, depth );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 3: // bottom\r\n\r\n\t\t\t\t\t// generate UVs along X then Z\r\n\t\t\t\t\tfaceDirVector.set( 0, - 1, 0 );\r\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\r\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'x', radius, depth );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 4: // front\r\n\r\n\t\t\t\t\t// generate UVs along X then Y\r\n\t\t\t\t\tfaceDirVector.set( 0, 0, 1 );\r\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'y', radius, width );\r\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 5: // back\r\n\r\n\t\t\t\t\t// generate UVs along X then Y\r\n\t\t\t\t\tfaceDirVector.set( 0, 0, - 1 );\r\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'x', 'y', radius, width );\r\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Factory method for creating an instance of this class from the given\r\n\t * JSON object.\r\n\t *\r\n\t * @param {Object} data - A JSON object representing the serialized geometry.\r\n\t * @returns {RoundedBoxGeometry} A new instance.\r\n\t */\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new RoundedBoxGeometry(\r\n\t\t\tdata.width,\r\n\t\t\tdata.height,\r\n\t\t\tdata.depth,\r\n\t\t\tdata.segments,\r\n\t\t\tdata.radius\r\n\t\t);\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport { RoundedBoxGeometry };\r\n"],
  "mappings": "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",
  "names": []
}
